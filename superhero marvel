#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <algorithm>

// Проста утиліта
using std::string;
using std::vector;
using std::shared_ptr;
using std::make_shared;
using std::cout;
using std::endl;

// ----------------- Здібності (абстрактний рівень + "інтерфейси") -----------------

// Базовий абстрактний клас Здатність
struct Ability {
    virtual ~Ability() = default;
    virtual string name() const = 0;
};

// "Інтерфейс" політ
struct IFlight : Ability {
    // повертає опис польоту / максимально можлива висота тощо
    virtual string flightInfo() const = 0;
};

// "Інтерфейс" суперсила (сила > щось)
struct ISuperStrength : Ability {
    virtual int strengthLevel() const = 0; // умовний показник сили
};

// "Інтерфейс" супершвидкість
struct ISuperSpeed : Ability {
    virtual double topSpeed() const = 0;
};

// Рентгенівський зір
struct IXRayVision : Ability {
    virtual string xrayRange() const = 0;
};

// Куленепробивність (брутальна проста здатність)
struct IBulletProof : Ability {
    virtual bool isBulletProof() const = 0;
};

// ----------------- Реалізації здібностей -----------------

struct FlightJetpack : IFlight {
    string name() const override { return "Jetpack Flight"; }
    string flightInfo() const override { return "Jetpack: medium height, controlled"; }
};

struct FlightGodly : IFlight {
    string name() const override { return "Godly Flight"; }
    string flightInfo() const override { return "Can fly at extreme altitudes and space travel"; }
};

struct SuperStrengthBasic : ISuperStrength {
    int level;
    SuperStrengthBasic(int lvl) : level(lvl) {}
    string name() const override { return "Super Strength"; }
    int strengthLevel() const override { return level; }
};

struct SuperSpeedFlashLike : ISuperSpeed {
    double speed;
    SuperSpeedFlashLike(double s) : speed(s) {}
    string name() const override { return "Super Speed"; }
    double topSpeed() const override { return speed; }
};

struct XRaySimple : IXRayVision {
    string name() const override { return "X-Ray Vision"; }
    string xrayRange() const override { return "Short-range x-ray vision"; }
};

struct BulletProofVest : IBulletProof {
    bool isBulletProof() const override { return true; }
    string name() const override { return "Bulletproof"; }
};

// ----------------- Категорії персонажів (абстрактні) -----------------

struct Alignment { virtual string kind() const = 0; virtual ~Alignment() = default; };
struct Good : Alignment { string kind() const override { return "Good"; } };
struct Evil : Alignment { string kind() const override { return "Evil"; } };

// Раса / походження
struct Race { virtual string name() const = 0; virtual ~Race() = default; };
struct Human : Race { string name() const override { return "Human"; } };
struct AnimalRace : Race { string name() const override { return "Animal"; } };
struct Deity : Race { string name() const override { return "Deity"; } };

// ----------------- Базовий клас СуперГерой -----------------

class SuperHero {
public:
    SuperHero(string n, shared_ptr<Rank> = nullptr) = delete; // другакова сигнатура вилучена (позначення)
    SuperHero(string n, shared_ptr<Alignment> align, shared_ptr<Race> race)
        : m_name(std::move(n)), m_alignment(std::move(align)), m_race(std::move(race)) {}

    virtual ~SuperHero() = default;

    const string& name() const { return m_name; }
    string alignment() const { return m_alignment ? m_alignment->kind() : "Neutral"; }
    string race() const { return m_race ? m_race->name() : "Unknown"; }

    void addAbility(const shared_ptr<Ability>& a) { m_abilities.push_back(a); }

    // Перевірка наявності здібності типу T (через dynamic_cast)
    template<typename T>
    bool hasAbility() const {
        for (auto &a : m_abilities) {
            if (dynamic_cast<T*>(a.get()) != nullptr) return true;
        }
        return false;
    }

    // Повернути всі назви здібностей
    vector<string> abilityNames() const {
        vector<string> out;
        for (auto &a : m_abilities) out.push_back(a->name());
        return out;
    }

    virtual string descriptor() const {
        string s = name() + " [" + alignment() + ", " + race() + "] Abilities: ";
        auto names = abilityNames();
        for (size_t i=0;i<names.size();++i) {
            s += names[i];
            if (i+1<names.size()) s += ", ";
        }
        return s;
    }

private:
    string m_name;
    shared_ptr<Alignment> m_alignment;
    shared_ptr<Race> m_race;
    vector<shared_ptr<Ability>> m_abilities;
};

// ----------------- Конкретні герої -----------------

struct Mystic : SuperHero {
    Mystic(const string& n) : SuperHero(n, make_shared<Good>(), make_shared<Human>()) {
        addAbility(make_shared<XRaySimple>());
    }
};

struct Wolverine : SuperHero {
    Wolverine(const string& n) : SuperHero(n, make_shared<Good>(), make_shared<Human>()) {
        addAbility(make_shared<SuperStrengthBasic>(80));
        addAbility(make_shared<BulletProofVest>()); // умова: стійкість (хай буде)
    }
};

struct TonyStark : SuperHero {
    TonyStark(const string& n) : SuperHero(n, make_shared<Good>(), make_shared<Human>()) {
        addAbility(make_shared<FlightJetpack>());
        addAbility(make_shared<SuperStrengthBasic>(20)); // броня дає якусь силу
    }
};

struct Groot : SuperHero {
    Groot(const string& n) : SuperHero(n, make_shared<Good>(), make_shared<AnimalRace>()) {
        addAbility(make_shared<SuperStrengthBasic>(60));
    }
};

struct Hulk : SuperHero {
    Hulk(const string& n) : SuperHero(n, make_shared<Good>(), make_shared<Deity>()) {
        addAbility(make_shared<SuperStrengthBasic>(150));
    }
};

struct CaptainAmerica : SuperHero {
    CaptainAmerica(const string& n) : SuperHero(n, make_shared<Good>(), make_shared<Human>()) {
        addAbility(make_shared<BulletProofVest>());
        addAbility(make_shared<SuperStrengthBasic>(50));
    }
};

struct ThorHero : SuperHero {
    ThorHero(const string& n) : SuperHero(n, make_shared<Good>(), make_shared<Deity>()) {
        addAbility(make_shared<FlightGodly>());
        addAbility(make_shared<SuperStrengthBasic>(200));
    }
};

struct LokiVillain : SuperHero {
    LokiVillain(const string& n) : SuperHero(n, make_shared<Evil>(), make_shared<Deity>()) {
        addAbility(make_shared<FlightGodly>());
        addAbility(make_shared<SuperStrengthBasic>(90));
    }
};

// ----------------- Тести в main -----------------

int main() {
    // Створюємо набір персонажів
    vector<shared_ptr<SuperHero>> roster;

    roster.push_back(make_shared<Mystic>("Mystic"));
    roster.push_back(make_shared<Wolverine>("Wolverine"));
    roster.push_back(make_shared<TonyStark>("Tony Stark"));
    roster.push_back(make_shared<Groot>("Groot"));
    roster.push_back(make_shared<Hulk>("Hulk"));
    roster.push_back(make_shared<CaptainAmerica>("Captain America"));
    roster.push_back(make_shared<ThorHero>("Thor"));
    roster.push_back(make_shared<LokiVillain>("Loki"));

    // Декілька додаткових прикладів: людина з супершвидкістю
    struct FlashLike : SuperHero {
        FlashLike(const string& n) : SuperHero(n, make_shared<Good>(), make_shared<Human>()) {
            addAbility(make_shared<SuperSpeedFlashLike>(1200.0)); // умовна величина
        }
    };
    roster.push_back(make_shared<FlashLike>("Quicksilver"));

    // Виведемо всіх героїв та їх здібності
    cout << "Roster of heroes:\n";
    for (auto &h : roster) {
        cout << " - " << h->descriptor() << '\n';
    }

    // Показати всіх, хто вміє літати (має IFlight)
    cout << "\nHeroes who can FLY:\n";
    for (auto &h : roster) {
        if (h->hasAbility<IFlight>()) {
            cout << " * " << h->name() << "  (" << h->descriptor() << ")\n";
        }
    }

    // Додатковий тест: знайти найсильнішого (ISuperStrength)
    shared_ptr<SuperHero> strongest = nullptr;
    int bestStrength = -1;
    for (auto &h : roster) {
        // Ітеруємо здібності через downcast до Ability і перевіряємо ISuperStrength
        // Оскільки abilities приватні, скористаємося прототипом: перевіримо hasAbility, а потім dynamic_cast через доступ до імені здібностей немає
        // Отримаємо грубий, але працюючий підхід: через тимчасове створення списку — спрощено: зробимо перевірку через відомі типи:
        // (у реальній системі додали б метод getAbilities())
        if (h->hasAbility<ISuperStrength>()) {
            // Щоб дізнатись рівень — потрібно отримати вказівку на саму здатність.
            // Для короткості — зробимо пошук через речення (не ідеально, але демонстраційно).
            // У цій реалізації ми не маємо прямого доступу до вектору здібностей, тому пропустимо точний рівень.
            // Позначимо якісь фіктивні значення за ім'ям.
            // (На практиці додайте в SuperHero метод getAbilities() для повного доступу).
            // Тут просто виведемо тих, у кого є сила:
            cout << " * Has super strength: " << h->name() << '\n';
        }
    }
}
